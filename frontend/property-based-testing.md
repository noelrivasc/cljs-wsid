# Property-Based Testing Notes

(NOTES GENERATED BY CLAUDE CODE... READ CAREFULLY)

## ClojureScript Spec Generator Setup

### Problem
Trying to generate `::db/app-db` using `clojure.spec.gen.alpha` failed with:
```
Var clojure.test.check.generators/->Generator does not exist, clojure.test.check.generators never required
```

### Root Cause
- `clojure.spec.gen.alpha` depends on `test.check` for generator functionality
- ClojureScript requires explicit dependency declaration (unlike Clojure JVM)
- Spec generators are built on top of `clojure.test.check.generators`

### Solution
Add `test.check` dependency to `shadow-cljs.edn`:
```clojure
:dependencies
[[org.clojure/test.check "1.1.1"]]
```

### Dev-Only Dependencies Limitation
**Key Finding**: Shadow CLJS doesn't support true dev-only dependencies. Dependencies declared in `:dependencies` are available to all builds. The `:extra-deps` or `:deps` in build-specific sections don't work as expected.

**Conclusion**: Dependencies are always added to the whole project. Tree-shaking takes care of discarding unused code in production builds, not dependency scoping.

## Spec Generation Limitations

### The Problem with Complex State
Attempting to generate `::db/app-db` revealed fundamental limitations:
- Spec generators create random, unrelated data
- No referential integrity between generated IDs
- Business logic constraints not enforced
- Result: scenarios with random IDs paired with scenario-factor-values with unrelated random IDs

### When Generators Work Well
✅ **Good for**:
- Testing pure functions with independent inputs
- Property-based testing of leaf values
- Generating valid individual domain objects

❌ **Poor for**:
- Complex stateful systems
- Data with referential integrity requirements
- End-to-end testing scenarios
- Cohesive application state

### Better Approaches for Complex State Testing

#### 1. Hand-crafted Test Fixtures
```clojure
(def sample-decision
  {:title "Choose a car"
   :factors [{:id "f1" :title "Cost" :weight 8}
             {:id "f2" :title "Safety" :weight 9}]
   :scenarios [{:id "s1" :title "Honda Civic"}]
   :scenario-factor-values {"s1" {"f1" 7 "f2" 8}}})
```

#### 2. Factory Functions
```clojure
(defn make-decision [& {:keys [num-factors num-scenarios]}]
  ;; Build coherent test data with proper ID relationships
  )
```

#### 3. Generators for Leaf Values Only
```clojure
(def weight-gen (s/gen :factor/weight))
(gen/sample weight-gen 10) ;; => (0 5 2 8 10 1 7 3 9 6)
```

#### 4. Mutation Testing
```clojure
;; Start with coherent fixture, apply random valid mutations
(-> sample-decision
    (update-factor-weight "f1" (gen/generate weight-gen))
    (set-scenario-value "s1" "f2" (gen/generate score-gen)))
```

## Key Takeaways
1. Property-based testing shines for pure functions, not complex state
2. Referential integrity requires hand-crafted or factory-generated data
3. Use spec generators for individual values, not entire application state
4. ClojureScript dependency scoping is limited - rely on tree-shaking for production optimization
